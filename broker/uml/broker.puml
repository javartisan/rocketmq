@startuml
'https://plantuml.com/sequence-diagram

skinparam handwritten true

BrokerStartup -> BrokerStartup : createBrokerController
note left
createBrokerController创建BrokerController,主要工作：
1：解析命令行参数
2：创建BrokerConfig
3：创建NettyServerConfig
4：创建NettyClientConfig
5：设置端口10911
6：创建MessageStoreConfig，里面会加载一些store存储目录的信息
7：如果指定了-c参数会读取broker.conf更新配置
8：new BrokerController(brokerConfig,nettyServerConfig,nettyClientConfig,messageStoreConfig);
end note
BrokerStartup -> BrokerController :initialize方法进行初始化
note right

1：加载/Users/store/config/topics.json文件
2：加载/Users/store/config/consumerOffset.json
3：/Users/store/config/subscriptionGroup.json
4：/Users/store/config/consumerFilter.json
5：实例化DefaultMessageStore
6：实例化BrokerStats
end note

BrokerController -> MessageStore : 调用load方法
note right
1：commitLog.load()
2：loadConsumeQueue()
3：indexService.load()
end note

MessageStore -> BrokerController :继续执行initialize方法
note  left
1: 创建NettyRemotingServer；分别remotingServer（10911端口监听）与fastRemotingServer(10909端口监听)，他们主要区别是在注册Processor：
    remotingServer注册了pullMessageProcessor，this.remotingServer.registerProcessor(RequestCode.PULL_MESSAGE, this.pullMessageProcessor, this.pullMessageExecutor);
    fastRemotingServer没有注册pullMessageProcessor，因此fastRemotingServer不处理客户端Consumer的请求
2：初始化一系列线程池，例如心跳等线程池
3：调用registerProcessor将步骤2里面的线程池注册到remotingServer与fastRemotingServer中，之外还注册一系列的NettyRequestProcessor用于处理请求
4：最后会启动定时任务，例如定时任务执行：consumerOffsetManager.persist()与consumerFilterManager.persist()例如心跳等线程池
5：initialTransaction();
6：initialAcl();
7：initialRpcHooks();
end note

BrokerController -> BrokerStartup: 继续执行createBrokerController方法
note left
注册关闭钩子：addShutdownHook，brokerController.shutdown()
end note


BrokerStartup -> BrokerController : start方法启动brokerController
note right
1： this.messageStore.start();
2： this.remotingServer.start();
3： this.fastRemotingServer.start();
4： this.fileWatchService.start();
5： this.brokerOuterAPI.start();
6： this.pullRequestHoldService.start();
7： this.clientHousekeepingService.start();
8： this.filterServerManager.start();
9： startProcessorByHa(messageStoreConfig.getBrokerRole());
10：handleSlaveSynchronize(messageStoreConfig.getBrokerRole());
11：this.registerBrokerAll(true, false, true); 比较重要的方法：会注册Broker到NameSvr
12：定时任务执行 BrokerController.this.registerBrokerAll(true, false, brokerConfig.isForceRegister());
13：this.brokerStatsManager.start();
14：this.brokerFastFailure.start();
end note

BrokerController -> BrokerStartup: 启动结束
@enduml